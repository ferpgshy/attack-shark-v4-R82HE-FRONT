import{u as H,G as L,ao as G,j as z,V as J,c as e,ap as O,a9 as a,键 as N,aq as E}from"./index.b078bf5f.js";import{u as F}from"./3ce44458.js";import{_ as Q}from"./a9ff247d.js";import{_ as U,a as W}from"./a8546291.js";const C=()=>{H();const R=L();return G({ref:R,onInit:g=>{e.keyboardState=e.createKeyboardState();const T=O(Q).Keyboard_82_NBD_IK75_KeyMappings(g),I=O(U).Keyboard_82_NBD_IK75_RT_On(g),b=O(W).Keyboard_82_NBD_IK75_RT_Off(g);T.root.appendChild(b.root),b.root.appendChild(I.root);const w=e.getCurrentDevice()?.deviceType.other?.knobKeyCodes??[];return F.addKeySelectionAndMappingEffects(T,void 0,void 0,void 0,w),F.addKeySelectionAndMappingEffects(b,void 0,void 0,void 0,w),F.addKeySelectionAndMappingEffects(I,void 0,void 0,void 0,w),{uiForRtOff:b,uiForRtOn:I,uiForKeyMappings:T}},onRefresh:({uiForRtOff:g,uiForRtOn:T,uiForKeyMappings:I})=>{const b=e.getCurrentDevice(),w=e.keyboardState.keys,h=T.status,u=g.status,o=I.status;F.updateKeyboard(I,t=>{const _=w[t];if(!_)return;const A=_.isHover,x=_.isSelected,S=e.getIs改键(t),y=e.getIs禁用(t),f=e.getIs高级键改键(t);new Set(e.getCurrentDevice()?.deviceType.other?.knobKeyCodes??[]),e.current键盘设置页SubpageIndex;const c=e.getCurrentDevice().磁轴.所有按键.find(n=>n.按键===t);c&&c.RT&&Object.values(o).forEach(v=>{v.id[t]&&(v.id[t].style.display="none")});const i=n=>{if(!n)return;if(!e.shouldSwitchBeDisplayed){const q=n.querySelectorAll("path")[0];q&&(q.style.display="none");const M=n.querySelectorAll("text")[1];M&&(M.style.display="none")}const K=e.getCurrentDevice()?.磁轴.所有按键.find(q=>q.按键===t);if(!K)return;const j=K?.轴体||"高特",V=n.querySelectorAll("path")[0];V&&V.setAttribute("fill",E(e.轴体颜色字典[j]||16771625));const P=e.supportedSwitchTypes.findIndex(q=>q===j),B=n.querySelectorAll("text")[1];B&&a.setText(B,String(P+1))};Object.values(o).forEach(n=>{n.id[t]&&(n.id[t].style.display="none")});const l=x&&A,m=x&&!A,D=!x&&A,p=!x&&!A;let r;const d=e.系统按键;if(e.isFnLayer&&d.has(t)){a.show(o.systemKey.id[t]),i(o.systemKey.id[t]);return}l?r=o.current_hover:m?r=o.current:D?S||f?r=o.changed:y?r=e.isFnLayer?o.hover:o.forbidden:r=o.hover:p&&(S||f?r=o.changed:y?e.isFnLayer?r=o.default:r=o.forbidden:r=o.default),r&&(a.show(r.id[t]),i(r.id[t]))}),F.updateKeyboard(g,t=>{const _=w[t];if(!_)return;if(new Set(e.getCurrentDevice()?.deviceType.other?.knobKeyCodes??[]).has(t)){Object.values(u).forEach(i=>{i.id[t]&&(i.id[t].style.display="none",i.id[t].setAttribute("pointer-events","none"),i.id[t].setAttribute("cursor","default"))});return}if(e.current键盘设置页SubpageIndex!==N.磁轴设置){g.status.default.id[t]&&Object.values(u).forEach(l=>{l.id[t]&&(l.id[t].style.display="none")});return}const S=e.getCurrentDevice().磁轴.所有按键.find(i=>i.按键===t);e.getIs改键(t),e.getIs禁用(t);const y=e.getIs高级键改键(t);if(e.getIsSwapKey(t),S){const{RT:i}=S;if(i||y){Object.values(u).forEach(l=>{l.id[t]&&(l.id[t].style.display="none")});return}}let f=_.isHover,s=_.isSelected;s&&(e.当前选中按键_单键=t,e.当前选中按键_多键.includes(t)||e.当前选中按键_多键.push(t));const c=i=>{if(!i)return;if(!e.shouldSwitchBeDisplayed){const d=i.querySelectorAll("path")[0];d&&(d.style.display="none");const n=i.querySelectorAll("text")[1];n&&(n.style.display="none")}const l=b.磁轴.所有按键.find(d=>d.按键===t);if(!l)return;const m=l?.轴体||"高特",D=i.querySelectorAll("path")[0];D&&D.setAttribute("fill",E(e.轴体颜色字典[m]||16771625));const p=e.supportedSwitchTypes.findIndex(d=>d===m),r=i.querySelectorAll("text")[1];if(r&&a.setText(r,String(p+1)),l&&l.行程设置.type==="行程设置"){let d=l.行程设置.行程按下,n=l.行程设置.行程抬起,v=i.querySelectorAll("text")[2],K=i.querySelectorAll("text")[3];v&&a.setText(v,d?.toFixed(e.travelPrecision)??"0.01"),K&&a.setText(K,n?.toFixed(e.travelPrecision)??"0.01")}};Object.values(u).forEach(i=>{i.id[t]&&(i.id[t].style.display="none")}),!s&&!f?(a.show(u.default.id[t]),c(u.default.id[t])):!s&&f?(a.show(u.hover.id[t]),c(u.hover.id[t])):s&&!f?(a.show(u.current.id[t]),c(u.current.id[t])):s&&f&&(a.show(u.current_hover.id[t]),c(u.current_hover.id[t]))}),F.updateKeyboard(T,t=>{const _=w[t];if(!_)return;if(new Set(e.getCurrentDevice()?.deviceType.other?.knobKeyCodes??[]),e.current键盘设置页SubpageIndex!==N.磁轴设置){Object.values(h).forEach(s=>{s.id[t]&&(s.id[t].style.display="none")});return}const x=e.getCurrentDevice().磁轴.所有按键.find(s=>s.按键===t);if(x){const{RT:s}=x;e.getIs改键(t),e.getIs禁用(t);const c=e.getIs高级键改键(t);if(e.getIsSwapKey(t),!s||c){Object.values(h).forEach(i=>{i.id[t]&&(i.id[t].style.display="none")});return}}let S=_.isHover,y=_.isSelected;y&&(e.当前选中按键_单键=t,e.当前选中按键_多键.includes(t)||e.当前选中按键_多键.push(t));const f=s=>{if(!s)return;if(!e.shouldSwitchBeDisplayed){const p=s.querySelectorAll("path")[0];p&&(p.style.display="none");const r=s.querySelectorAll("text")[1];r&&(r.style.display="none")}const c=b.磁轴.所有按键.find(p=>p.按键===t);if(!c)return;const i=c?.轴体||"高特",l=s.querySelectorAll("path")[0];l&&l.setAttribute("fill",E(e.轴体颜色字典[i]||16771625));const m=e.supportedSwitchTypes.findIndex(p=>p===i),D=s.querySelectorAll("text")[1];if(D&&a.setText(D,String(m+1)),c&&c.行程设置.type==="行程设置"){let p=c.行程设置.行程按下,r=c.rt抬起,d=c.rt按下,n=s.querySelectorAll("text")[2],v=s.querySelectorAll("text")[3],K=s.querySelectorAll("text")[4];n&&a.setText(n,p.toFixed(e.travelPrecision)),v&&a.setText(v,d?.toFixed(e.travelPrecision)??"0.01"),K&&a.setText(K,r?.toFixed(e.travelPrecision)??"0.01")}};Object.values(h).forEach(s=>{s.id[t]&&(s.id[t].style.display="none")}),!y&&!S?(a.show(h.default.id[t]),f(h.default.id[t])):!y&&S?(a.show(h.hover.id[t]),f(h.hover.id[t])):y&&!S?(a.show(h.current.id[t]),f(h.current.id[t])):y&&S&&(a.show(h.current_hover.id[t]),f(h.current_hover.id[t]))})}}),z.jsx(J,{divRef:R})};export{C as Keyboard_82_NBD_IK75_v4_KeyMappings_RT};
