import{u as M,G as j,ao as R,j as P,V as H,c as e,ap as O,键 as q,a9 as f}from"./index.b078bf5f.js";import{u as F}from"./3ce44458.js";import{_ as L}from"./8117b76c.js";import{_ as W,a as G}from"./528233b2.js";const N=()=>{M();const D=j();return R({ref:D,onInit:y=>{e.keyboardState=e.createKeyboardState();const v=O(L).Keyboard_81_MK830_KeyMappings(y),K=O(W).Keyboard_81_MK830_RT_On(y),T=O(G).Keyboard_81_MK830_RT_Off(y);v.root.appendChild(T.root),T.root.appendChild(K.root);const _=new Set(["AudioVolumeUp","AudioVolumeMute","AudioVolumeDown"]),E=()=>e.current键盘设置页SubpageIndex===q.自定义按键||e.current键盘设置页SubpageIndex===q.磁轴设置||e.current键盘设置页SubpageIndex===q.高级设置;return F.addKeySelectionAndMappingEffects(v,_,E),F.addKeySelectionAndMappingEffects(T,_,E,"current"),F.addKeySelectionAndMappingEffects(K,_,E,"current"),_.forEach(n=>{Object.values(v.status).forEach(l=>{if(_.has(n)){const s=l.id[n];s&&(s.querySelectorAll("g").forEach(S=>{S.id.startsWith("Frame")}),s.querySelectorAll("path#Vector").forEach(S=>{}))}}),Object.values(T.status).forEach(l=>{if(_.has(n)){const s=l.id[n];s&&(s.querySelectorAll("g").forEach(r=>{r.id.startsWith("Frame")&&r.remove()}),s.querySelectorAll("path#Vector").forEach(r=>{r.setAttribute("fill","white")}),s.querySelectorAll("text").forEach(r=>{r.remove()}))}}),Object.values(K.status).forEach(l=>{if(_.has(n)){const s=l.id[n];s&&(s.querySelectorAll("g").forEach(r=>{r.id.startsWith("Frame")&&r.remove()}),s.querySelectorAll("path#Vector").forEach(r=>{r.setAttribute("fill","white")}),s.querySelectorAll("text").forEach(r=>{r.remove()}))}})}),{uiForRtOff:T,uiForRtOn:K,uiForKeyMappings:v,nonMagneticKeys:_}},onRefresh:({uiForRtOff:y,uiForRtOn:v,uiForKeyMappings:K,nonMagneticKeys:T})=>{const _=e.getCurrentDevice(),E=e.keyboardState.keys,n=v.status,l=y.status,s=K.status;F.updateKeyboard(K,t=>{const u=E[t];if(!u)return;const S=u.isHover,r=u.isSelected,x=e.getIs改键(t),p=e.getIs禁用(t),h=e.getIs高级键改键(t);if(e.current键盘设置页SubpageIndex===q.磁轴设置&&!h){K.status.default.id[t]&&Object.values(s).forEach(b=>{b.id[t]&&(b.id[t].style.display="none")});return}const a=e.getCurrentDevice().磁轴.所有按键.find(d=>d.按键===t);a&&a.RT&&Object.values(s).forEach(b=>{b.id[t]&&(b.id[t].style.display="none")});const o=d=>{if(!d)return;const b=d.querySelectorAll("path")[0];b&&(b.style.display="none");const V=d.querySelectorAll("text")[1];V&&(V.style.display="none")};Object.values(s).forEach(d=>{d.id[t]&&(d.id[t].style.display="none")});const g=r&&S,m=r&&!S,A=!r&&S,I=!r&&!S;let c;const w=e.系统按键;if(e.isFnLayer&&w.has(t)){f.show(s.systemKey.id[t]),o(s.systemKey.id[t]);return}g?c=s.current_hover:m?c=s.current:A?x||h?c=s.changed:p?c=e.isFnLayer?s.hover:s.forbidden:c=s.hover:I&&(x||h?c=s.changed:p?e.isFnLayer?c=s.default:c=s.forbidden:c=s.default),c&&(f.show(c.id[t]),o(c.id[t]))}),F.updateKeyboard(y,t=>{const u=E[t];if(!u)return;if(e.current键盘设置页SubpageIndex!==q.磁轴设置){y.status.default.id[t]&&Object.values(l).forEach(o=>{o.id[t]&&(o.id[t].style.display="none")});return}const r=e.getCurrentDevice().磁轴.所有按键.find(a=>a.按键===t);e.getIs改键(t),e.getIs禁用(t);const x=e.getIs高级键改键(t);if(e.getIsSwapKey(t),r){const{RT:a}=r;if(a||x){Object.values(l).forEach(o=>{o.id[t]&&(o.id[t].style.display="none")});return}}let p=u.isHover,h=u.isSelected;h&&(e.当前选中按键_单键=t,e.当前选中按键_多键.includes(t)||e.当前选中按键_多键.push(t));const i=a=>{if(!a)return;const o=a.querySelectorAll("path")[0];o&&(o.style.display="none");const g=a.querySelectorAll("text")[1];g&&(g.style.display="none");const m=_.磁轴.所有按键.find(A=>A.按键===t);if(m&&m.行程设置.type==="行程设置"){let A=m.行程设置.行程按下,I=m.行程设置.行程抬起,c=a.querySelectorAll("text")[2],w=a.querySelectorAll("text")[3];c&&f.setText(c,A?.toFixed(e.travelPrecision)??"0.01"),w&&f.setText(w,I?.toFixed(e.travelPrecision)??"0.01")}};Object.values(l).forEach(a=>{a.id[t]&&(a.id[t].style.display="none")}),!h&&!p?(f.show(l.default.id[t]),i(l.default.id[t])):!h&&p?(f.show(l.hover.id[t]),i(l.hover.id[t])):h&&!p?(f.show(l.current.id[t]),i(l.current.id[t])):h&&p&&(f.show(l.current_hover.id[t]),i(l.current_hover.id[t]))}),F.updateKeyboard(v,t=>{const u=E[t];if(!u)return;if(e.current键盘设置页SubpageIndex!==q.磁轴设置){Object.values(n).forEach(i=>{i.id[t]&&(i.id[t].style.display="none")});return}const r=e.getCurrentDevice().磁轴.所有按键.find(i=>i.按键===t);if(r){const{RT:i}=r;e.getIs改键(t),e.getIs禁用(t);const a=e.getIs高级键改键(t);if(e.getIsSwapKey(t),!i||a){Object.values(n).forEach(o=>{o.id[t]&&(o.id[t].style.display="none")});return}}let x=u.isHover,p=u.isSelected;p&&(e.当前选中按键_单键=t,e.当前选中按键_多键.includes(t)||e.当前选中按键_多键.push(t));const h=i=>{if(!i)return;const a=i.querySelectorAll("path")[0];a&&(a.style.display="none");const o=i.querySelectorAll("text")[1];o&&(o.style.display="none");const g=_.磁轴.所有按键.find(m=>m.按键===t);if(g&&g.行程设置.type==="行程设置"){let m=g.行程设置.行程按下,A=g.rt抬起,I=g.rt按下,c=i.querySelectorAll("text")[2],w=i.querySelectorAll("text")[3],d=i.querySelectorAll("text")[4];c&&f.setText(c,m.toFixed(e.travelPrecision)),w&&f.setText(w,I?.toFixed(e.travelPrecision)??"0.01"),d&&f.setText(d,A?.toFixed(e.travelPrecision)??"0.01")}};Object.values(n).forEach(i=>{i.id[t]&&(i.id[t].style.display="none")}),!p&&!x?(f.show(n.default.id[t]),h(n.default.id[t])):!p&&x?(f.show(n.hover.id[t]),h(n.hover.id[t])):p&&!x?(f.show(n.current.id[t]),h(n.current.id[t])):p&&x&&(f.show(n.current_hover.id[t]),h(n.current_hover.id[t]))})}}),P.jsx(H,{divRef:D})};export{N as Keyboard_81_MK830_v2_KeyMappings_RT};
